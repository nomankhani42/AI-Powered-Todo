# Implementation Plan: Command-Line Todo Application

**Branch**: `001-todo-cli` | **Date**: 2025-12-05 | **Spec**: [specs/001-todo-cli/spec.md](spec.md)
**Input**: Feature specification from `/specs/001-todo-cli/spec.md`

## Summary

Build a command-line todo application that stores tasks in memory with support for five core operations: add, delete, update, list, and complete. The application will follow spec-driven development principles with modular architecture (models → storage → commands → CLI), comprehensive type hints, and all business logic unit-testable. No persistence layer required; single-threaded, single-user interaction via REPL loop.

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: (None required for runtime; dev tools: pytest, ruff, mypy)
**Storage**: In-memory dictionary with sequential ID generation
**Testing**: pytest for unit and integration tests
**Target Platform**: Cross-platform CLI (Linux, macOS, Windows)
**Project Type**: Single command-line application
**Performance Goals**: All operations < 100ms, linear memory scaling, supports 10,000 tasks
**Constraints**: No external databases, no file persistence, no complex CLI frameworks (simple input parsing)
**Scale/Scope**: Single-user, single-threaded, 5 core commands, max 10,000 in-memory tasks

## Constitution Check

**GATE VALIDATION** ✅ **PASS** — All principles aligned:

- ✅ **Clean Code Standards**: Requires type hints for all functions, docstrings for public APIs, PEP 8 compliance, single-responsibility functions
- ✅ **Project Structure**: Uses UV as package manager, Python 3.13+, modular organization (models, storage, commands, CLI)
- ✅ **Development Methodology**: Spec-driven (specification complete), independently testable features (each CRUD operation testable in isolation)
- ✅ **Data Management**: In-memory storage (no databases), proper data structures (dict for O(1) lookup), data integrity (sequential IDs, validation)
- ✅ **User Experience**: CLI feedback for every operation (✓ success, ✗ error, ℹ info), error messages guide users, consistent command patterns
- ✅ **Code Quality Gates**: No global state (all state in TodoCLI instance), unit testable business logic, input validation at CLI boundary, explicit (no magic)

**Constraints Check**:
- ✅ No databases or file storage (in-memory only)
- ✅ Exactly 5 features (add, delete, update, list, complete)
- ✅ Simple input parsing (no Click, argparse, or Typer)
- ✅ No over-engineering (YAGNI approach)
- ✅ Input validation required (all user inputs validated at CLI layer)
- ✅ Feedback on every operation (success/error/info messages)

**Result**: No violations. Plan proceeds to design phase.

## Project Structure

### Documentation (specs/001-todo-cli/)

```text
specs/001-todo-cli/
├── spec.md                      # Feature specification (5 user stories, 13 requirements)
├── plan.md                      # This file (implementation architecture)
├── research.md                  # (Phase 0) Research on patterns and best practices
├── data-model.md                # (Phase 1) Task entity definition and state transitions
├── quickstart.md                # (Phase 1) Quick start guide for developers
├── contracts/                   # (Phase 1) API/command contracts
│   └── commands.md              # Command interface definitions
├── checklists/
│   └── requirements.md          # Specification quality validation (all items pass)
└── tasks.md                     # (Phase 2) Generated by /sp.tasks command
```

### Source Code Structure (repository root)

```text
src/
└── todo_cli/
    ├── __init__.py              # Package initialization (version, exports)
    ├── __main__.py              # Entry point: `python -m todo_cli`
    ├── main.py                  # Application bootstrap
    ├── models.py                # Task dataclass (id, description, completed, created_at)
    ├── store.py                 # TaskStore class (in-memory CRUD storage)
    ├── commands.py              # TodoCommands class (business logic layer)
    └── cli.py                   # TodoCLI class (REPL, input parsing, output formatting)

tests/
├── __init__.py
├── test_models.py               # Unit tests for Task validation
├── test_store.py                # Unit tests for TaskStore CRUD operations
├── test_commands.py             # Unit tests for command handlers
└── test_cli.py                  # Integration tests for end-to-end flows

Configuration Files (repository root):
├── pyproject.toml               # UV/Python configuration, dependencies, tool settings
├── README.md                    # Project overview, installation, usage examples
└── .gitignore                   # Git ignore rules
```

**Structure Decision**: Single-project CLI application (Option 1). The modular structure within `src/todo_cli/` enforces separation of concerns (models → storage → commands → CLI) while keeping the project lean and focused. Tests mirror the source structure for clarity.

## Component Architecture

### Layer Model

```
┌────────────────────────────────────────────────────────────┐
│                    Application Entry                        │
│  __main__.py / main.py - Bootstrap TodoCLI instance         │
└────────────────────────────┬─────────────────────────────────┘
                             │
┌────────────────────────────▼─────────────────────────────────┐
│                  CLI Layer (cli.py)                          │
│  - REPL loop: prompt → parse → execute → display            │
│  - parse_command(input) → (command: str, args: list[str])   │
│  - execute(command, args) → processes command via commands  │
│  - display_result(result) → formatted output to stdout      │
│  - Error handling: catches exceptions, displays user help   │
└────────────────────────────┬─────────────────────────────────┘
                             │
┌────────────────────────────▼─────────────────────────────────┐
│              Command Layer (commands.py)                     │
│  - TodoCommands class wraps business logic                  │
│  - add(description: str) → CommandResult                    │
│  - delete(task_id: int) → CommandResult                     │
│  - update(task_id: int, description: str) → CommandResult   │
│  - list_all() → CommandResult                               │
│  - complete(task_id: int) → CommandResult                   │
│  - Validation before operations, structured error messages  │
└────────────────────────────┬─────────────────────────────────┘
                             │
┌────────────────────────────▼─────────────────────────────────┐
│               Storage Layer (store.py)                       │
│  - TaskStore class manages in-memory state                  │
│  - _tasks: dict[int, Task] → O(1) task lookup              │
│  - _next_id: int → auto-increment for sequential IDs        │
│  - CRUD methods: add, get, get_all, update, delete          │
│  - mark_complete(task_id) for completion status            │
└────────────────────────────┬─────────────────────────────────┘
                             │
┌────────────────────────────▼─────────────────────────────────┐
│                Model Layer (models.py)                       │
│  - @dataclass Task(id, description, completed, created_at)  │
│  - __post_init__ validation: non-empty, max 200 chars        │
│  - Type hints: int, str, bool, datetime                      │
│  - Immutable or frozen where appropriate                     │
└────────────────────────────────────────────────────────────────┘
```

### Data Flow

```
User Input (CLI)
      ↓
parse_command() → (command, args)
      ↓
execute(command, args)
      ↓
TodoCommands.{add|delete|update|list_all|complete}()
      ↓
Validation + TaskStore operations
      ↓
CommandResult(success, message, data)
      ↓
display_result() → formatted output
```

## Implementation Phases

### Phase 0: Research & Design Decisions

**Objectives**: Resolve architectural unknowns, document patterns

**Outputs**:
- `research.md`: Best practices for Python CLI design, dataclass validation, in-memory storage patterns

**Tasks**:
1. Research Python CLI patterns (simple input loops vs frameworks)
2. Review dataclass validation best practices
3. Document error handling patterns
4. Review testing patterns for stateful objects

**No code changes**. Pure research to inform Phase 1 design.

---

### Phase 1: Project Setup & Configuration

**Objectives**: Initialize project structure, configure dependencies, set up tooling

**Duration**: ~1 hour

**Deliverables**:
- ✓ UV project initialized
- ✓ Python 3.13+ configured
- ✓ Dev dependencies installed (pytest, ruff, mypy)
- ✓ Directory structure created
- ✓ `pyproject.toml` configured
- ✓ `README.md` with overview
- ✓ Git repository ready

**Files to Create**:
1. `pyproject.toml` (dependencies: pytest, ruff, mypy)
2. `src/todo_cli/__init__.py` (package version, exports)
3. `src/todo_cli/__main__.py` (entry point)
4. `README.md` (project overview, installation, usage)
5. `tests/__init__.py` (test package)
6. `.gitignore` (Python defaults)

**Implementation Details**:

```toml
# pyproject.toml
[project]
name = "todo-cli"
version = "0.1.0"
description = "Simple command-line todo application"
requires-python = ">=3.13"

[dependency-groups]
dev = [
    "pytest>=8.0",
    "ruff>=0.4",
    "mypy>=1.10",
]
```

```python
# src/todo_cli/__main__.py
from .main import main
if __name__ == "__main__":
    main()
```

**Acceptance**:
- `uv sync` runs without errors
- `python -m todo_cli --help` (or similar) works
- Directory structure matches plan

---

### Phase 2: Data Model & Storage

**Objectives**: Define Task entity, implement in-memory storage with CRUD operations

**Duration**: ~2 hours

**Deliverables**:
- ✓ `models.py`: Task dataclass with validation
- ✓ `store.py`: TaskStore with CRUD + ID generation
- ✓ `test_models.py`: Unit tests for Task
- ✓ `test_store.py`: Unit tests for TaskStore
- ✓ `data-model.md`: Entity definitions

**Files to Create**:
1. `src/todo_cli/models.py`
2. `src/todo_cli/store.py`
3. `tests/test_models.py`
4. `tests/test_store.py`
5. `specs/001-todo-cli/data-model.md`

**Implementation Details**:

```python
# models.py
from dataclasses import dataclass, field
from datetime import datetime

@dataclass
class Task:
    """Represents a single task in the todo application."""
    id: int
    description: str
    completed: bool = False
    created_at: datetime = field(default_factory=datetime.now)

    def __post_init__(self) -> None:
        """Validate task on creation."""
        if not self.description or not self.description.strip():
            raise ValueError("Description cannot be empty")
        if len(self.description) > 200:
            raise ValueError("Description must not exceed 200 characters")
```

```python
# store.py
from typing import Optional
from .models import Task

class TaskStore:
    """In-memory storage for tasks with auto-incrementing IDs."""

    def __init__(self) -> None:
        """Initialize empty store."""
        self._tasks: dict[int, Task] = {}
        self._next_id: int = 1

    def add(self, description: str) -> Task:
        """Create and store a new task."""
        task = Task(id=self._next_id, description=description)
        self._tasks[self._next_id] = task
        self._next_id += 1
        return task

    def get(self, task_id: int) -> Optional[Task]:
        """Retrieve a task by ID."""
        return self._tasks.get(task_id)

    def get_all(self) -> list[Task]:
        """Return all tasks in creation order."""
        return list(self._tasks.values())

    def update(self, task_id: int, description: str) -> Optional[Task]:
        """Update a task's description."""
        if task_id not in self._tasks:
            return None
        task = self._tasks[task_id]
        task.description = description  # Validation done in Task.__post_init__
        return task

    def delete(self, task_id: int) -> bool:
        """Delete a task by ID."""
        if task_id in self._tasks:
            del self._tasks[task_id]
            return True
        return False

    def mark_complete(self, task_id: int) -> Optional[Task]:
        """Mark a task as completed."""
        if task_id not in self._tasks:
            return None
        task = self._tasks[task_id]
        task.completed = True
        return task
```

**Tests**:
- Task creation and validation
- TaskStore CRUD operations
- ID auto-increment behavior
- Edge cases (non-existent IDs, empty descriptions, etc.)

**Acceptance**:
- `pytest tests/test_models.py tests/test_store.py -v` passes
- `mypy src/todo_cli/models.py src/todo_cli/store.py` shows no errors
- 100% of public functions have type hints and docstrings

---

### Phase 3: Command Handlers

**Objectives**: Implement business logic layer with validation and error handling

**Duration**: ~2 hours

**Deliverables**:
- ✓ `commands.py`: TodoCommands class with all 5 operations
- ✓ `test_commands.py`: Unit tests for all command handlers
- ✓ `contracts/commands.md`: Command interface specification

**Files to Create**:
1. `src/todo_cli/commands.py`
2. `tests/test_commands.py`
3. `specs/001-todo-cli/contracts/commands.md`

**Implementation Details**:

```python
# commands.py
from dataclasses import dataclass
from typing import Any, Optional
from .models import Task
from .store import TaskStore

@dataclass
class CommandResult:
    """Structured result from a command."""
    success: bool
    message: str
    data: Any = None

class TodoCommands:
    """Command handlers for todo operations."""

    def __init__(self, store: TaskStore) -> None:
        """Initialize with a task store."""
        self.store = store

    def add(self, description: str) -> CommandResult:
        """Add a new task."""
        try:
            description = description.strip()
            if not description:
                return CommandResult(False, "Error: Description cannot be empty")
            if len(description) > 200:
                return CommandResult(False, "Error: Description must not exceed 200 characters")
            task = self.store.add(description)
            return CommandResult(True, f"✓ Task added successfully (ID: {task.id})", task)
        except ValueError as e:
            return CommandResult(False, f"✗ Error: {str(e)}")

    def delete(self, task_id: int) -> CommandResult:
        """Delete a task by ID."""
        try:
            if not isinstance(task_id, int):
                return CommandResult(False, "✗ Error: Please provide a valid task ID (number)")
            if self.store.delete(task_id):
                return CommandResult(True, f"✓ Task {task_id} deleted successfully")
            return CommandResult(False, f"✗ Error: Task with ID {task_id} not found")
        except Exception as e:
            return CommandResult(False, f"✗ Error: {str(e)}")

    def update(self, task_id: int, description: str) -> CommandResult:
        """Update a task's description."""
        try:
            if not isinstance(task_id, int):
                return CommandResult(False, "✗ Error: Please provide a valid task ID (number)")
            description = description.strip()
            if not description:
                return CommandResult(False, "✗ Error: Description cannot be empty")
            if len(description) > 200:
                return CommandResult(False, "✗ Error: Description must not exceed 200 characters")
            task = self.store.update(task_id, description)
            if task:
                return CommandResult(True, f"✓ Task {task_id} updated successfully", task)
            return CommandResult(False, f"✗ Error: Task with ID {task_id} not found")
        except Exception as e:
            return CommandResult(False, f"✗ Error: {str(e)}")

    def list_all(self) -> CommandResult:
        """List all tasks."""
        tasks = self.store.get_all()
        if not tasks:
            return CommandResult(True, "No tasks found. Add a task using 'add <description>'", [])
        return CommandResult(True, "Tasks:", tasks)

    def complete(self, task_id: int) -> CommandResult:
        """Mark a task as complete."""
        try:
            if not isinstance(task_id, int):
                return CommandResult(False, "✗ Error: Please provide a valid task ID (number)")
            task = self.store.get(task_id)
            if not task:
                return CommandResult(False, f"✗ Error: Task with ID {task_id} not found")
            if task.completed:
                return CommandResult(True, f"ℹ Task {task_id} is already complete", task)
            self.store.mark_complete(task_id)
            return CommandResult(True, f"✓ Task {task_id} marked as complete", task)
        except Exception as e:
            return CommandResult(False, f"✗ Error: {str(e)}")
```

**Tests**:
- Each command with valid inputs
- Each command with invalid inputs (missing IDs, non-existent tasks)
- Boundary conditions (empty descriptions, too-long descriptions)
- Error messages match specification

**Acceptance**:
- `pytest tests/test_commands.py -v` passes
- All error messages match specification exactly
- All return types are CommandResult

---

### Phase 4: CLI Interface

**Objectives**: Implement REPL loop, input parsing, and output formatting

**Duration**: ~2 hours

**Deliverables**:
- ✓ `cli.py`: TodoCLI with REPL loop
- ✓ `main.py`: Application bootstrap
- ✓ `test_cli.py`: Integration tests
- ✓ `quickstart.md`: Developer quick start

**Files to Create**:
1. `src/todo_cli/cli.py`
2. `src/todo_cli/main.py`
3. `tests/test_cli.py`
4. `specs/001-todo-cli/quickstart.md`

**Implementation Details**:

```python
# cli.py
from .store import TaskStore
from .commands import TodoCommands, CommandResult
from .models import Task

class TodoCLI:
    """Command-line interface for the todo application."""

    def __init__(self) -> None:
        """Initialize CLI with empty store."""
        self.store = TaskStore()
        self.commands = TodoCommands(self.store)
        self.running = False

    def run(self) -> None:
        """Main REPL loop."""
        self.running = True
        print("Welcome to todo-cli! Type 'help' for available commands.")
        while self.running:
            try:
                user_input = input("> ").strip()
                if not user_input:
                    continue
                self.execute(user_input)
            except KeyboardInterrupt:
                print("\nGoodbye!")
                self.running = False
            except EOFError:
                print("\nGoodbye!")
                self.running = False

    def execute(self, user_input: str) -> None:
        """Parse and execute a command."""
        parts = user_input.split(None, 2)  # Split on whitespace, max 3 parts
        if not parts:
            return

        command = parts[0].lower()
        args = parts[1:] if len(parts) > 1 else []

        if command == "add":
            if not args:
                print("✗ Error: Missing required argument. Usage: add <description>")
                return
            result = self.commands.add(args[0])
            self.display_result(result)

        elif command == "delete":
            if not args:
                print("✗ Error: Missing required argument. Usage: delete <id>")
                return
            try:
                task_id = int(args[0])
                result = self.commands.delete(task_id)
                self.display_result(result)
            except ValueError:
                print("✗ Error: Please provide a valid task ID (number)")

        elif command == "update":
            if len(args) < 2:
                print("✗ Error: Missing required argument. Usage: update <id> <description>")
                return
            try:
                task_id = int(args[0])
                description = " ".join(args[1:])
                result = self.commands.update(task_id, description)
                self.display_result(result)
            except ValueError:
                print("✗ Error: Please provide a valid task ID (number)")

        elif command == "list":
            result = self.commands.list_all()
            self.display_result(result)

        elif command == "complete":
            if not args:
                print("✗ Error: Missing required argument. Usage: complete <id>")
                return
            try:
                task_id = int(args[0])
                result = self.commands.complete(task_id)
                self.display_result(result)
            except ValueError:
                print("✗ Error: Please provide a valid task ID (number)")

        elif command == "help":
            self.display_help()

        elif command == "exit":
            self.running = False
            print("Goodbye!")

        else:
            print("Unknown command. Type 'help' for available commands.")

    def display_result(self, result: CommandResult) -> None:
        """Display a command result."""
        print(result.message)
        if result.data and isinstance(result.data, list):
            self.display_tasks_table(result.data)
        elif result.data and isinstance(result.data, Task):
            self.display_tasks_table([result.data])

    def display_tasks_table(self, tasks: list[Task]) -> None:
        """Display tasks in a formatted table."""
        if not tasks:
            return

        # Calculate column widths
        id_width = 4
        desc_width = 20
        status_width = 10

        # Print header
        print(f"┌{'─' * (id_width + 2)}┬{'─' * (desc_width + 2)}┬{'─' * (status_width + 2)}┐")
        print(f"│ {'ID'.center(id_width)} │ {'Description'.center(desc_width)} │ {'Status'.center(status_width)} │")
        print(f"├{'─' * (id_width + 2)}┼{'─' * (desc_width + 2)}┼{'─' * (status_width + 2)}┤")

        # Print rows
        for task in tasks:
            status = "[✓] Done" if task.completed else "[ ] Todo"
            desc = task.description[:desc_width].ljust(desc_width)
            print(f"│ {str(task.id).center(id_width)} │ {desc} │ {status.center(status_width)} │")

        print(f"└{'─' * (id_width + 2)}┴{'─' * (desc_width + 2)}┴{'─' * (status_width + 2)}┘")

    def display_help(self) -> None:
        """Display help message."""
        help_text = """
Available commands:
  add <description>       - Add a new task
  delete <id>            - Delete a task by ID
  update <id> <desc>     - Update a task's description
  list                   - View all tasks
  complete <id>          - Mark a task as complete
  help                   - Show this help message
  exit                   - Exit the application
"""
        print(help_text)

# main.py
from .cli import TodoCLI

def main() -> None:
    """Application entry point."""
    cli = TodoCLI()
    cli.run()
```

**Tests**:
- Command parsing (valid and invalid)
- Each command flow end-to-end
- Table formatting
- Error message display

**Acceptance**:
- `pytest tests/test_cli.py -v` passes
- `python -m todo_cli` starts a working REPL
- All commands work as specified

---

### Phase 5: Quality & Testing

**Objectives**: Full test coverage, code quality checks, documentation

**Duration**: ~1 hour

**Deliverables**:
- ✓ Unit test coverage > 90%
- ✓ No ruff linting errors
- ✓ No mypy type errors
- ✓ All docstrings present
- ✓ README with examples

**Tasks**:
1. Review all test coverage
2. Run `ruff check src/ tests/`
3. Run `mypy src/ tests/`
4. Fix any issues found
5. Add missing docstrings
6. Update README with usage examples

**Acceptance**:
- `ruff check src/ tests/` → 0 errors
- `mypy src/ tests/` → 0 errors
- Test coverage > 90%
- README includes examples

---

### Phase 6: Integration & Documentation

**Objectives**: Final integration testing, documentation completeness

**Duration**: ~1 hour

**Deliverables**:
- ✓ End-to-end workflows tested manually
- ✓ All specification acceptance scenarios verified
- ✓ Developer documentation complete
- ✓ Code ready for `/sp.tasks` phase

**Tasks**:
1. Manual end-to-end testing (add → view → complete → delete workflows)
2. Verify all 18 acceptance scenarios from spec
3. Test error paths (invalid inputs, non-existent IDs, etc.)
4. Final documentation review
5. Prepare for task generation

**Acceptance**:
- All acceptance scenarios from spec.md pass
- Manual testing documents and approved
- No outstanding bugs or TODOs
- Ready to proceed to `/sp.tasks`

---

## Development Sequence

```
Phase 1          Phase 2            Phase 3           Phase 4           Phase 5       Phase 6
(Setup)          (Models+Store)     (Commands)        (CLI)             (Quality)     (Integration)
  │                   │                  │                │                 │             │
  ├─ pyproject.toml   ├─ models.py       ├─ commands.py   ├─ cli.py         ├─ ruff      ├─ Manual tests
  ├─ package setup    ├─ store.py        ├─ test_cmd      ├─ main.py        ├─ mypy      ├─ Verify spec
  ├─ README           ├─ test_models     │                ├─ test_cli       ├─ coverage  ├─ Documentation
  └─ .gitignore       ├─ test_store      │                ├─ quickstart.md  └─ docs      └─ Ready for tasks
                      └─ data-model.md   └─ contracts/
```

**Sequential** — Each phase builds on previous. Minimal parallelization possible (e.g., tests written while code in progress).

## Testing Strategy

### Unit Tests (Phases 2, 3, 4)

**models.py**:
- Task creation with valid inputs
- Task validation (empty, too long, valid descriptions)
- Task default values (completed=False, auto-created_at)

**store.py**:
- CRUD operations (add, get, get_all, update, delete)
- ID auto-increment (sequential, no gaps)
- get() returns None for non-existent IDs
- delete() returns True/False appropriately
- mark_complete() idempotent

**commands.py**:
- Each command with valid inputs
- Error messages for invalid inputs
- Validation boundaries (empty descriptions, 200-char limit)
- Task not found scenarios

**cli.py**:
- Command parsing (single args, multi-word descriptions)
- Table formatting
- REPL loop behavior
- Help command output

### Integration Tests (Phase 6)

- Full workflow: add 3 tasks → list → complete 1 → update 1 → delete 1 → list
- Error recovery: invalid command → continue to next command
- Edge cases: empty input, unknown commands, missing arguments

### Quality Gates

```
ruff check src/ tests/          → 0 errors (PEP 8 compliance)
mypy src/ tests/                → 0 errors (type safety)
pytest --cov src/               → >90% coverage
docstring check                 → 100% of public functions have docstrings
type hint check                 → 100% of parameters and returns typed
```

## Dependencies

### Runtime
- Python 3.13+ (no external packages needed for MVP)

### Development
```toml
[dependency-groups]
dev = [
    "pytest>=8.0",          # Testing framework
    "ruff>=0.4",            # Linter + formatter
    "mypy>=1.10",           # Static type checker
    "pytest-cov>=4.0",      # Coverage reporting (optional)
]
```

## Risk Mitigation

| Risk | Mitigation | Contingency |
|------|------------|------------|
| Scope creep | Stick to 5 features only (per constitution) | PR review enforces spec adherence |
| Over-engineering | YAGNI principle, simple input parsing | Code review flags unnecessary complexity |
| Missing edge cases | Acceptance scenarios test boundaries | Additional edge case tests in Phase 6 |
| Type errors late in development | mypy checks after each phase | Fix immediately before proceeding |
| Incomplete tests | Test as you code (TDD when possible) | Phase 5 fills any gaps |
| Performance issues | Target < 100ms, test with 10k tasks | Optimize dict operations if needed |

## Success Metrics

- [x] Constitution compliance verified (all 6 principles, all constraints)
- [ ] Phase 1: Project setup complete, `uv sync` works
- [ ] Phase 2: Models and storage layer 100% tested
- [ ] Phase 3: Commands layer 100% tested
- [ ] Phase 4: CLI layer 100% tested, `python -m todo_cli` runs
- [ ] Phase 5: All quality gates pass (ruff, mypy, coverage>90%, docstrings 100%)
- [ ] Phase 6: All 18 acceptance scenarios from spec pass
- [ ] All 5 core commands functional (add, delete, update, list, complete)
- [ ] All error messages match specification
- [ ] Code ready for production use (no TODOs, no warnings)

## Next Steps

1. Run `/sp.tasks` to generate the concrete task breakdown
2. Begin Phase 1 (project setup) implementation
3. Track progress against checklist above
4. Create PHR after implementation is complete
